/*
 * Copyright 2017, Data61
 * Commonwealth Scientific and Industrial Research Organisation (CSIRO)
 * ABN 41 687 119 230.
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(DATA61_BSD)
 */

import <std_connector.camkes>;
import <global-connectors.camkes>;

import "components/OpenTitanUARTDriver/OpenTitanUARTDriver.camkes";
import "components/DebugConsole/DebugConsole.camkes";
import "components/ProcessManager/ProcessManager.camkes";
import "components/MlCoordinator/MlCoordinator.camkes";
import "components/MemoryManager/MemoryManager.camkes";
import "components/StorageManager/StorageManager.camkes";
import "components/SecurityCoordinator/SecurityCoordinator.camkes"; 
import "components/TimerService/TimerService.camkes";

component OpenTitanUART {
    hardware;
    dataport Buf mmio_region;

    emits Interrupt tx_watermark;
    emits Interrupt rx_watermark;
    emits Interrupt tx_empty;
}

component OpenTitanTimer {
    hardware;
    dataport Buf csr;

    emits Interrupt timer_interrupt;
}

component VectorCoreHw {
    hardware;
    dataport Buf csr;
    dataport Buf(0x100000) itcm;
    dataport Buf(0x1000000) dtcm;

    emits Interrupt host_req;
    emits Interrupt finish;
    emits Interrupt instruction_fault;
    emits Interrupt data_fault;
}

component BuiltinCpioArchive {
    hardware;
    dataport Buf(0x1000000) cpio;
}

assembly {
    composition {
        component VectorCoreHw vctop;
        component BuiltinCpioArchive cpio;

        component OpenTitanUART uart;
        component OpenTitanUARTDriver uart_driver;
        component OpenTitanTimer timer;

        component MemoryManager memory_manager;
        component ProcessManager process_manager;
        component MlCoordinator ml_coordinator;
        component DebugConsole debug_console;
        component SecurityCoordinator security_coordinator;
        component StorageManager storage_manager;
        component TimerService timer_service;

        // Built-in CPIO archive is visible only to DebugConsole.
        connection seL4HardwareMMIO cpio_archive(from debug_console.cpio_archive,
                                                 to cpio.cpio);

        // OpenTitanUARTDriver
        connection seL4HardwareMMIO uart_mem(from uart_driver.mmio_region,
                                             to uart.mmio_region);
        connection seL4HardwareInterrupt uart_tx_watermark(from uart.tx_watermark,
                                                           to uart_driver.tx_watermark);
        connection seL4HardwareInterrupt uart_rx_watermark(from uart.rx_watermark,
                                                           to uart_driver.rx_watermark);
        connection seL4HardwareInterrupt uart_tx_empty(from uart.tx_empty,
                                                       to uart_driver.tx_empty);

        // VectorCoreDriver
        connection seL4HardwareMMIO vc_csr(from ml_coordinator.csr, to vctop.csr);
        connection seL4HardwareInterrupt vctop_host_req(from vctop.host_req,
                                                      to ml_coordinator.host_req);
        connection seL4HardwareInterrupt vctop_finish(from vctop.finish,
                                                      to ml_coordinator.finish);
        connection seL4HardwareInterrupt vctop_instruction_fault(from vctop.instruction_fault,
                                                      to ml_coordinator.instruction_fault);
        connection seL4HardwareInterrupt vctop_data_fault(from vctop.data_fault,
                                                      to ml_coordinator.data_fault);
        connection seL4HardwareMMIO vc_itcm(from ml_coordinator.itcm,
                                            to vctop.itcm);
        connection seL4HardwareMMIO vc_dtcm(from ml_coordinator.dtcm,
                                            to vctop.dtcm);


        // TimerService
        connection seL4HardwareMMIO timer_csr(from timer_service.csr,
                                            to timer.csr);
        connection seL4HardwareInterrupt timer_interrupt(from timer.timer_interrupt,
                                                       to timer_service.timer_interrupt);
        connection seL4RPCCallSignal timer_rpc(from debug_console.timer,
                                                to timer_service.timer);

        // Hookup ProcessManager to DebugConsole for shell commands.
        connection seL4RPCCall shell_process(from debug_console.proc_ctrl,
                                             to process_manager.proc_ctrl);
        connection seL4RPCCall shell_ml(from debug_console.mlcoord,
                                        to ml_coordinator.mlcoord);
        connection seL4RPCCall shell_storage(from debug_console.storage,
                                             to storage_manager.storage);

        // Note this allocates a 4KB shared memory region for pkg install
        // to pass an ObjDescArray
        connection seL4RPCOverMultiSharedData shell_package(
            from debug_console.pkg_mgmt,
            to process_manager.pkg_mgmt);

        // Connect the MemoryInterface to each component that needs to allocate
        // global memory. Note this allocates a 4KB shared memory region to each
        // component and copies data between components.
        connection seL4RPCOverMultiSharedData multi_memory(
            from debug_console.memory,
            from process_manager.memory,
            from security_coordinator.memory,
            // TOOD(sleffler): from ml_coordinator.memory,
            to memory_manager.memory);

        // Connect the SecurityCoordinatorInterface to each component that needs
        // access to the Security Core. Note this allocates a 4KB shared memory
        // region to each component and copies data between components.
        connection seL4RPCOverMultiSharedData multi_security(
            from debug_console.security,   // NB: for debug/test
            from process_manager.security,
            from ml_coordinator.security,  // NB: for LoadModel but not in design
            from storage_manager.security,
            to security_coordinator.security);

        // Connect the DebugConsole to the OpenTitanUARTDriver.
        connection seL4SharedData tx_channel(
            from debug_console.tx_dataport, to uart_driver.tx_dataport);
        connection seL4RPCCall write_call(
            from debug_console.uart_write, to uart_driver.write);
        connection seL4SharedData rx_channel(
            from debug_console.rx_dataport, to uart_driver.rx_dataport);
        connection seL4RPCCall read_call(
            from debug_console.uart_read, to uart_driver.read);

        // Connect the LoggerInterface to each component that needs to log
        // to the console. Note this allocates a 4KB shared memory region to
        // each component and copies data between components.
        connection seL4RPCOverMultiSharedData multi_logger(
            from process_manager.logger,
            from ml_coordinator.logger,
            from memory_manager.logger,
            from security_coordinator.logger,
            from storage_manager.logger,
            from timer_service.logger,
            to debug_console.logger);
    }

    configuration {
        cpio.cpio_paddr = 0x46000000;
        cpio.cpio_size = 0x1000000;

        uart.mmio_region_paddr = 0x50000000;
        uart.mmio_region_size = 0x1000;
        uart.tx_watermark_irq_number = 1;
        uart.rx_watermark_irq_number = 2;
        uart.tx_empty_irq_number = 3;

        vctop.csr_paddr = 0x47000000;
        vctop.csr_size = 0x1000;
        vctop.itcm_paddr = 0x32000000;
        vctop.itcm_size = 0x100000;
        vctop.dtcm_paddr = 0x34000000;
        vctop.dtcm_size = 0x1000000;
        vctop.host_req_irq_number = 13;          // kTopMatchaPlicIrqIdVcTopHostReq @ top_matcha.h
        vctop.finish_irq_number = 14;            // kTopMatchaPlicIrqIdVcTopFinish @ top_matcha.h
        vctop.instruction_fault_irq_number = 15; // kTopMatchaPlicIrqIdVcTopInstructionFault @ top_matcha.h
        vctop.data_fault_irq_number = 16;        // kTopMatchaPlicIrqIdVcTopDataFault @ top_matcha.h

        timer.csr_paddr = 0x50030000;
        timer.csr_size = 0x1000;

        // Placeholder interrupt number, not represented in top_matcha.h.
        timer.timer_interrupt_irq_number = 31;

        random.ID = 1;

        uart.integrity_label = "opentitan_uart_driver";
    }
}

// Uncomment to run a concurrency test component that is runnable every time
// the scheduler checks and which periodically calls logger.log.
//
// (Needs to be at the bottom of file because CAmkES ADL does not have forward
// declaration.)
// import "components/LogFibonacci/assembly.camkes";
